#version 450

layout(local_size_x = 256) in;

struct Point {
    vec3 position;
    float padding0;
    vec3 color;
    float intensity;
};

struct Node {
    uint parent;
    uint left;
    uint right;
    uint isLeaf;
    uint mortonCode;
    uint prefixLen;
    uint pointStart;
    uint pointCount;
};

struct AABB {
    vec3 min;
    float padding1;
    vec3 max;
    float padding2;
};

layout(set = 0, binding = 0) uniform UniformData {
    AABB bounds;
    uint numPoints;
    uint numUnique;
} u_data;

// Helper Functions
uint expandBits(uint v) {
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint morton3D(vec3 pos, vec3 min_b, vec3 extent) {
    vec3 norm = (pos - min_b) / extent;
    float x = clamp(norm.x, 0.0, 1.0);
    float y = clamp(norm.y, 0.0, 1.0);
    float z = clamp(norm.z, 0.0, 1.0);

    uint xx = expandBits(uint(x * 7.0)); // 10 bits per axis
    uint yy = expandBits(uint(y * 7.0));
    uint zz = expandBits(uint(z * 7.0));
    return (xx << 2) | (yy << 1) | zz;
}

layout(std430, set = 0, binding = 1) readonly buffer InputPoints { Point points[]; };
layout(std430, set = 0, binding = 2) writeonly buffer OutCodes { uint codes[]; };
layout(std430, set = 0, binding = 3) writeonly buffer OutIndices { uint indices[]; };

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= u_data.numPoints) return;

    vec3 extent = u_data.bounds.max - u_data.bounds.min;
    // Avoid division by zero
    if (extent.x < 0.0001) extent.x = 1.0;
    if (extent.y < 0.0001) extent.y = 1.0;
    if (extent.z < 0.0001) extent.z = 1.0;

    codes[idx] = morton3D(points[idx].position, u_data.bounds.min, extent);
    indices[idx] = idx;
}