#version 450

layout(local_size_x = 256) in;

struct Point {
    vec3 position;
    vec3 color;
    float intensity;
};

struct Node {
    uint parent;
    uint left;
    uint right;
    uint isLeaf;
    uint mortonCode;
    uint prefixLen;
    uint pointStart;
    uint pointCount;
};

struct AABB {
    vec3 min;
    vec3 max;
};

layout(set = 0, binding = 0) uniform UniformData {
    AABB bounds;
    uint numPoints;
    uint numUnique;
} u_data;

// Helper Functions
uint expandBits(uint v) {
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint morton3D(vec3 pos, vec3 min_b, vec3 extent) {
    vec3 norm = (pos - min_b) / extent;
    float x = clamp(norm.x, 0.0, 1.0);
    float y = clamp(norm.y, 0.0, 1.0);
    float z = clamp(norm.z, 0.0, 1.0);

    uint xx = expandBits(uint(x * 1023.0)); // 10 bits per axis
    uint yy = expandBits(uint(y * 1023.0));
    uint zz = expandBits(uint(z * 1023.0));
    return (xx << 2) | (yy << 1) | zz;
}

layout(std430, set = 0, binding = 1) readonly buffer SortedCodes { uint codes[]; };
layout(std430, set = 0, binding = 2) writeonly buffer HeadFlags { uint flags[]; };

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= u_data.numPoints) return;

    if (idx == 0) {
        flags[idx] = 1;
    } else {
        flags[idx] = (codes[idx] != codes[idx - 1]) ? 1 : 0;
    }
}