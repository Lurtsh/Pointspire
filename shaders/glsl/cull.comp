#version 450
layout(local_size_x = 256) in;

struct Point {
    vec3 position;
    vec3 color;
    float intensity;
};

struct IndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(set = 0, binding = 0) uniform Camera {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout(std430, set = 0, binding = 1) readonly buffer SourceBuffer {
    Point points[];
} source;

layout(std430, set = 0, binding = 2) writeonly buffer VisibleBuffer {
    Point points[];
} destination;

layout(std430, set = 0, binding = 3) buffer IndirectBuffer {
    IndirectCommand cmd;
};

layout(set = 0, binding = 4) uniform CullInfo {
    uint totalCount;
} info;

shared uint s_GroupVisibleCount;
shared uint s_GlobalBaseIndex;

void main() {
    if (gl_LocalInvocationID.x == 0) {
        s_GroupVisibleCount = 0;
        s_GlobalBaseIndex = 0;
    }
    barrier();

    uint groupIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
    uint idx = groupIndex * gl_WorkGroupSize.x + gl_LocalInvocationID.x;

    bool isVisible = false;
    Point p;

    if (idx < info.totalCount) {
        p = source.points[idx];
        vec4 clipPos = ubo.proj * ubo.view * vec4(p.position, 1.0);

        isVisible = (abs(clipPos.x) <= clipPos.w) &&
        (abs(clipPos.y) <= clipPos.w) &&
        (clipPos.z >= 0.0 && clipPos.z <= clipPos.w);
    }

    uint localOffset = 0;
    if (isVisible) {
        localOffset = atomicAdd(s_GroupVisibleCount, 1);
    }

    barrier();

    if (gl_LocalInvocationID.x == 0) {
        if (s_GroupVisibleCount > 0) {
            s_GlobalBaseIndex = atomicAdd(cmd.instanceCount, s_GroupVisibleCount);
        }
    }

    barrier();

    if (isVisible) {
        destination.points[s_GlobalBaseIndex + localOffset] = p;
    }
}
